# 完整的开发/生产环境分离方案

## 1. 前提条件与环境现状分析

### 1.1 项目现状

**技术栈：**
- 前端：Next.js 15.1.0 + React 18 + TypeScript
- 后端：Strapi 5.33.4 + Node.js 20
- 数据库（开发）：SQLite
- 数据库（生产）：PostgreSQL 16

**当前架构：**
```
开发环境：
├── 前端：http://localhost:3000
├── 后端：http://localhost:1337
└── 数据库：SQLite (backend/.tmp/data.db)
```

**域名：**
- 生产域名：szzczk.com

### 1.2 现有配置文件

| 文件路径 | 用途 | 状态 |
|---------|------|------|
| `backend/.env` | 开发环境配置 | ✅ 已存在 |
| `backend/.env.example` | 开发环境示例 | ✅ 已存在 |
| `frontend/.env.example` | 前端环境示例 | ✅ 已存在 |
| `frontend/.env` | 前端开发配置 | ❌ 未创建（使用默认值） |

### 1.3 前置条件

**软件要求：**
- Docker 24.0+
- Docker Compose 2.20+
- Node.js 20.x
- OpenSSL（用于生成密钥）
- Git

**服务器要求：**
- CPU：2核以上
- 内存：4GB 以上
- 磁盘：20GB 以上
- 网络：公网 IP + 域名解析

---

## 2. 环境分离的具体目标与原则

### 2.1 目标

| 目标 | 描述 |
|------|------|
| **开发环境** | 使用 SQLite，快速启动，支持热重载，便于功能迭代 |
| **生产环境** | 使用 PostgreSQL，容器化部署，高可用，数据持久化 |
| **配置隔离** | 开发和生产环境配置完全独立，互不影响 |
| **安全合规** | 敏感信息不提交到代码仓库，生产环境使用 HTTPS |
| **自动化** | 部署流程自动化，减少人工操作错误 |

### 2.2 原则

1. **配置分离原则**：不同环境使用不同的配置文件
2. **最小权限原则**：生产环境只开放必要的端口和服务
3. **数据安全原则**：敏感信息加密存储，定期备份
4. **可追溯原则**：所有操作记录日志，便于问题排查
5. **自动化优先原则**：尽可能使用脚本和工具自动化操作

---

## 3. 详细的实现架构设计

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        生产环境                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐      ┌──────────────┐                   │
│  │   Nginx      │      │   Docker     │                   │
│  │   (反向代理)  │◄─────┤   Compose    │                   │
│  │   443/80     │      │   (编排)     │                   │
│  └──────────────┘      └──────────────┘                   │
│         │                        │                          │
│         │                        │                          │
│    ┌────┴────┐            ┌──────┴────────┐                 │
│    │         │            │               │                 │
│    ▼         ▼            ▼               ▼                 │
│ ┌──────┐ ┌──────┐   ┌──────────┐  ┌──────────────┐        │
│ │Front │ │Back  │   │PostgreSQL│  │Volumes      │        │
│ │end   │ │end   │   │Database  │  │(数据持久化)  │        │
│ │:3000 │ │:1337 │   │:5432     │  │              │        │
│ └──────┘ └──────┘   └──────────┘  └──────────────┘        │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                        开发环境                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐      ┌──────────────┐                   │
│  │   Next.js    │      │   Strapi     │                   │
│  │   :3000      │─────►│   :1337      │                   │
│  │   (前端)     │      │   (后端)     │                   │
│  └──────────────┘      └──────┬───────┘                   │
│                                │                            │
│                                ▼                            │
│                        ┌──────────────┐                     │
│                        │   SQLite     │                     │
│                        │  (数据库)    │                     │
│                        └──────────────┘                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 目录结构

```
/Users/will/Downloads/figma/zczk/
├── backend/
│   ├── .env                    # 开发环境配置（不提交）
│   ├── .env.example            # 开发环境示例
│   ├── .env.production         # 生产环境模板（提交）
│   ├── Dockerfile              # 后端容器镜像
│   ├── .dockerignore           # Docker 忽略文件
│   ├── config/
│   │   ├── database.ts         # 数据库配置（支持多环境）
│   │   ├── middlewares.ts      # 中间件配置（含 CORS）
│   │   └── ...
│   └── ...
├── frontend/
│   ├── .env                    # 开发环境配置（不提交）
│   ├── .env.example            # 开发环境示例
│   ├── .env.production         # 生产环境模板（提交）
│   ├── Dockerfile              # 前端容器镜像
│   ├── .dockerignore           # Docker 忽略文件
│   ├── next.config.ts          # Next.js 配置
│   └── ...
├── docker/
│   ├── .env.example            # Docker 环境变量示例
│   ├── .env                    # Docker 敏感信息（不提交）
│   ├── docker-compose.yml      # 生产环境编排
│   ├── docker-compose.dev.yml  # 开发环境编排（可选）
│   ├── nginx.conf              # Nginx 配置
│   └── ssl/                    # SSL 证书目录
├── scripts/
│   ├── dev.sh                  # 开发环境启动脚本
│   ├── prod.sh                 # 生产环境部署脚本
│   ├── deploy.sh               # 自动化部署脚本
│   ├── generate-secrets.sh     # 生成密钥脚本
│   └── backup.sh               # 数据备份脚本
├── .gitignore                 # Git 忽略文件
└── README.md                  # 项目文档
```

### 3.3 网络架构

**开发环境网络：**
```
浏览器 → localhost:3000 (Next.js) → localhost:1337 (Strapi) → SQLite
```

**生产环境网络：**
```
用户浏览器 → szczk.com:443 (Nginx) → frontend:3000 (Next.js)
                                      → backend:1337 (Strapi) → postgres:5432 (PostgreSQL)
```

---

## 4. 环境配置管理策略

### 4.1 配置文件分层

| 配置文件 | 用途 | 提交 Git | 包含内容 |
|---------|------|----------|----------|
| `backend/.env` | 开发环境本地配置 | ❌ | SQLite 配置、本地密钥 |
| `backend/.env.example` | 开发环境示例 | ✅ | 配置模板（不含敏感信息） |
| `backend/.env.production` | 生产环境模板 | ✅ | PostgreSQL 配置、变量引用 |
| `frontend/.env` | 开发环境本地配置 | ❌ | 本地 API URL |
| `frontend/.env.example` | 开发环境示例 | ✅ | 配置模板 |
| `frontend/.env.production` | 生产环境模板 | ✅ | 生产 API URL |
| `docker/.env.example` | Docker 环境变量示例 | ✅ | 所有环境变量（不含真实值） |
| `docker/.env` | Docker 敏感信息 | ❌ | 密码、密钥等敏感信息 |

### 4.2 环境变量分类

**自动生成的变量（7个）：**
```env
POSTGRES_PASSWORD          # PostgreSQL 密码
APP_KEYS                   # Strapi 应用密钥（4个）
API_TOKEN_SALT             # API 令牌盐
ADMIN_JWT_SECRET           # Admin JWT 密钥
TRANSFER_TOKEN_SALT        # Transfer 令牌盐
JWT_SECRET                 # JWT 密钥
ENCRYPTION_KEY             # 加密密钥
```

**手动定义的变量（1个）：**
```env
DOMAIN                     # 网站域名（szzczk.com）
```

### 4.3 配置文件内容

**`backend/.env`（开发环境）：**
```env
HOST=0.0.0.0
PORT=1337
DATABASE_CLIENT=sqlite
DATABASE_FILENAME=.tmp/data.db
APP_KEYS="toBeModified1,toBeModified2"
API_TOKEN_SALT=tobemodified
ADMIN_JWT_SECRET=tobemodified
TRANSFER_TOKEN_SALT=tobemodified
JWT_SECRET=tobemodified
ENCRYPTION_KEY=tobemodified
```

**`backend/.env.production`（生产环境模板）：**
```env
HOST=0.0.0.0
PORT=1337
NODE_ENV=production
DATABASE_CLIENT=postgres
DATABASE_HOST=postgres
DATABASE_PORT=5432
DATABASE_NAME=strapi_prod
DATABASE_USERNAME=strapi_user
DATABASE_PASSWORD=${POSTGRES_PASSWORD}
DATABASE_SCHEMA=public
DATABASE_POOL_MIN=2
DATABASE_POOL_MAX=10

APP_KEYS=${APP_KEYS}
API_TOKEN_SALT=${API_TOKEN_SALT}
ADMIN_JWT_SECRET=${ADMIN_JWT_SECRET}
TRANSFER_TOKEN_SALT=${TRANSFER_TOKEN_SALT}
JWT_SECRET=${JWT_SECRET}
ENCRYPTION_KEY=${ENCRYPTION_KEY}

URL=https://${DOMAIN}
PUBLIC_URL=https://${DOMAIN}
```

**`frontend/.env`（开发环境）：**
```env
NEXT_PUBLIC_STRAPI_URL=http://localhost:1337
```

**`frontend/.env.production`（生产环境模板）：**
```env
NEXT_PUBLIC_STRAPI_URL=https://${DOMAIN}/api
```

**`docker/.env.example`（示例）：**
```env
# PostgreSQL 数据库
POSTGRES_PASSWORD=your_secure_password_here

# Strapi 应用密钥（4个随机字符串，逗号分隔）
APP_KEYS=key1,key2,key3,key4

# API 令牌盐
API_TOKEN_SALT=your_api_token_salt_here

# Admin JWT 密钥
ADMIN_JWT_SECRET=your_admin_jwt_secret_here

# Transfer 令牌盐
TRANSFER_TOKEN_SALT=your_transfer_token_salt_here

# JWT 密钥
JWT_SECRET=your_jwt_secret_here

# 加密密钥
ENCRYPTION_KEY=your_encryption_key_here

# 域名
DOMAIN=your-domain.com
```

---

## 5. 部署流程与自动化方案

### 5.1 开发环境部署流程

**手动启动：**
```bash
# 终端 1：启动后端
cd backend
npm run develop

# 终端 2：启动前端
cd frontend
npm run dev
```

**使用脚本启动：**
```bash
./scripts/dev.sh
```

**特点：**
- 使用 SQLite 数据库
- 支持热重载
- 快速启动（< 10秒）
- 数据存储在 `backend/.tmp/data.db`

### 5.2 生产环境部署流程

**首次部署：**
```bash
# 1. 生成环境变量
./scripts/generate-secrets.sh szczk.com

# 2. 编辑 docker/.env（如果需要）
vim docker/.env

# 3. 启动容器
cd docker
docker-compose up -d --build

# 4. 等待容器启动（约 30-60 秒）
docker-compose logs -f

# 5. 导入数据（首次部署）
docker-compose exec backend npm run strapi import

# 6. 验证数据
docker-compose exec backend npm run strapi list products
```

**自动化部署：**
```bash
./scripts/deploy.sh
```

**脚本功能：**
- 停止旧容器
- 构建新镜像
- 启动新容器
- 等待服务就绪
- 检查是否需要导入数据
- 验证部署状态

### 5.3 数据迁移流程

**从开发环境导出：**
```bash
cd backend
npm run strapi export
```

**导入到生产环境：**
```bash
cd docker
docker-compose exec backend npm run strapi import
```

**迁移时机：**
- 首次部署后
- 开发环境有重大数据更新时
- 生产环境数据损坏需要恢复时

---

## 6. 数据隔离与安全措施

### 6.1 数据隔离

| 环境 | 数据库 | 数据位置 | 隔离方式 |
|------|--------|----------|----------|
| 开发环境 | SQLite | `backend/.tmp/data.db` | 本地文件，独立存储 |
| 生产环境 | PostgreSQL | Docker Volume | 容器化，持久化存储 |

### 6.2 安全措施

**1. 敏感信息保护：**
- 所有 `.env` 文件添加到 `.gitignore`
- 使用强密码（16位以上随机字符串）
- 定期轮换密钥

**2. 网络安全：**
- 生产环境使用 HTTPS
- Nginx 反向代理隐藏后端服务
- 只开放必要端口（80, 443）

**3. 访问控制：**
- Strapi Admin 面板需要登录
- API 接口使用 CORS 限制
- 数据库只允许容器内部访问

**4. 数据备份：**
```bash
# 备份数据库
docker exec zczk-postgres pg_dump -U strapi_user strapi_prod > backup.sql

# 备份上传文件
docker run --rm -v zczk_backend_uploads:/data -v $(pwd):/backup alpine tar czf /backup/uploads.tar.gz -C /data .
```

### 6.3 SSL/TLS 配置

**使用 Let's Encrypt：**
```bash
# 安装 certbot
sudo apt-get install certbot

# 生成证书
sudo certbot certonly --standalone -d szczk.com -d www.szzczk.com

# 复制证书到 docker/ssl
sudo cp /etc/letsencrypt/live/szzczk.com/fullchain.pem docker/ssl/
sudo cp /etc/letsencrypt/live/szzczk.com/privkey.pem docker/ssl/
```

**自动续期：**
```bash
# 添加 crontab 任务
0 0 * * * certbot renew --quiet && docker restart zczk-nginx
```

---

## 7. 测试与验证方法

### 7.1 开发环境测试

**功能测试：**
```bash
# 1. 启动开发环境
./scripts/dev.sh

# 2. 访问前端
open http://localhost:3000

# 3. 测试 API
curl http://localhost:1337/api/products
curl http://localhost:1337/api/news

# 4. 测试数据库
cd backend
sqlite3 .tmp/data.db ".tables"
```

### 7.2 生产环境测试

**容器健康检查：**
```bash
# 检查所有容器状态
docker-compose ps

# 查看容器日志
docker-compose logs -f

# 测试 PostgreSQL 连接
docker-compose exec postgres psql -U strapi_user -d strapi_prod -c "\l"

# 测试 Strapi API
curl https://szzczk.com/api/products
curl https://szzczk.com/api/news

# 测试前端
curl https://szzczk.com
```

**性能测试：**
```bash
# 使用 Apache Bench 测试
ab -n 1000 -c 10 https://szzczk.com/

# 使用 wrk 测试
wrk -t4 -c100 -d30s https://szzczk.com/
```

### 7.3 回滚测试

**回滚流程：**
```bash
# 1. 停止当前版本
cd docker
docker-compose down

# 2. 恢复旧版本镜像
docker tag zczk-backend:old zczk-backend:latest
docker tag zczk-frontend:old zczk-frontend:latest

# 3. 启动旧版本
docker-compose up -d

# 4. 验证回滚成功
docker-compose ps
```

---

## 8. 运维监控与故障处理机制

### 8.1 监控方案

**容器监控：**
```bash
# 实时查看容器状态
docker-compose ps

# 查看资源使用情况
docker stats

# 查看容器日志
docker-compose logs -f [service_name]
```

**日志管理：**
```bash
# 查看所有日志
docker-compose logs

# 查看特定服务日志
docker-compose logs backend
docker-compose logs frontend
docker-compose logs postgres

# 查看最近 100 行日志
docker-compose logs --tail=100
```

**健康检查：**
```bash
# 检查 PostgreSQL
docker-compose exec postgres pg_isready -U strapi_user

# 检查 Strapi
curl -f https://szzczk.com/api/products || echo "Strapi 不可用"

# 检查前端
curl -f https://szzczk.com || echo "前端不可用"
```

### 8.2 故障处理

**常见故障及解决方案：**

| 故障现象 | 可能原因 | 解决方案 |
|---------|---------|----------|
| 容器无法启动 | 端口被占用 | 检查端口占用，修改 docker-compose.yml |
| 数据库连接失败 | PostgreSQL 未启动 | 检查 PostgreSQL 健康状态，等待启动 |
| API 请求失败 | CORS 配置错误 | 检查 Strapi CORS 配置 |
| 前端无法访问 | Nginx 配置错误 | 检查 nginx.conf 配置 |
| SSL 证书过期 | 证书未续期 | 运行 certbot renew |

**故障排查流程：**
```bash
# 1. 检查容器状态
docker-compose ps

# 2. 查看日志
docker-compose logs

# 3. 检查网络连接
docker network inspect zczk_zczk-network

# 4. 检查资源使用
docker stats

# 5. 重启服务
docker-compose restart [service_name]
```

### 8.3 告警机制

**使用 Docker Healthcheck：**
```yaml
services:
  backend:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:1337/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**使用外部监控工具（可选）：**
- Prometheus + Grafana
- Datadog
- New Relic

---

## 9. 实施步骤与时间规划

### 9.1 实施步骤

**阶段 1：准备工作（1-2 天）**

| 步骤 | 任务 | 输出 |
|------|------|------|
| 1.1 | 安装 PostgreSQL 驱动 | `backend/package.json` 更新 |
| 1.2 | 创建配置文件模板 | `.env.production` 文件 |
| 1.3 | 创建 Dockerfile | `backend/Dockerfile`, `frontend/Dockerfile` |
| 1.4 | 创建 Docker Compose 配置 | `docker/docker-compose.yml` |
| 1.5 | 创建 Nginx 配置 | `docker/nginx.conf` |
| 1.6 | 创建部署脚本 | `scripts/*.sh` |

**阶段 2：本地测试（1-2 天）**

| 步骤 | 任务 | 验证 |
|------|------|------|
| 2.1 | 生成环境变量 | `docker/.env` 创建成功 |
| 2.2 | 构建容器镜像 | 镜像构建无错误 |
| 2.3 | 启动容器 | 所有容器正常运行 |
| 2.4 | 测试数据库连接 | PostgreSQL 连接成功 |
| 2.5 | 导入测试数据 | 数据导入成功 |
| 2.6 | 测试 API 接口 | API 响应正常 |

**阶段 3：生产部署（1 天）**

| 步骤 | 任务 | 验证 |
|------|------|------|
| 3.1 | 部署到服务器 | 容器在服务器上运行 |
| 3.2 | 配置域名解析 | 域名指向服务器 IP |
| 3.3 | 配置 SSL 证书 | HTTPS 访问正常 |
| 3.4 | 执行数据迁移 | 生产数据导入成功 |
| 3.5 | 全功能测试 | 所有功能正常 |
| 3.6 | 配置备份策略 | 自动备份正常运行 |

**阶段 4：优化与监控（持续）**

| 步骤 | 任务 | 频率 |
|------|------|------|
| 4.1 | 性能优化 | 按需 |
| 4.2 | 安全加固 | 按需 |
| 4.3 | 监控告警 | 持续 |
| 4.4 | 定期备份 | 每天 |
| 4.5 | 日志分析 | 每周 |

### 9.2 时间规划

| 阶段 | 时间 | 关键里程碑 |
|------|------|-----------|
| 准备工作 | 1-2 天 | 所有配置文件创建完成 |
| 本地测试 | 1-2 天 | 本地 Docker 环境运行正常 |
| 生产部署 | 1 天 | 生产环境上线 |
| 优化监控 | 持续 | 系统稳定运行 |

**总计：3-5 天完成首次部署**

---

## 10. 风险评估与应对策略

### 10.1 风险评估

| 风险 | 概率 | 影响 | 风险等级 |
|------|------|------|----------|
| 数据迁移失败 | 中 | 高 | 高 |
| 容器启动失败 | 低 | 中 | 中 |
| SSL 证书配置错误 | 中 | 中 | 中 |
| 性能不达标 | 低 | 中 | 中 |
| 安全漏洞 | 低 | 高 | 中 |
| 数据丢失 | 低 | 高 | 高 |

### 10.2 应对策略

**风险 1：数据迁移失败**
- **预防措施：**
  - 在测试环境先演练迁移流程
  - 迁移前完整备份数据
  - 使用事务确保数据一致性
- **应对措施：**
  - 保留开发环境数据作为备份
  - 准备回滚方案
  - 记录详细日志便于排查

**风险 2：容器启动失败**
- **预防措施：**
  - 在本地充分测试
  - 使用健康检查机制
  - 配置自动重启策略
- **应对措施：**
  - 查看容器日志定位问题
  - 检查资源使用情况
  - 必要时回滚到旧版本

**风险 3：SSL 证书配置错误**
- **预防措施：**
  - 使用 Let's Encrypt 自动化
  - 配置自动续期
  - 在测试环境先验证
- **应对措施：**
  - 使用 HTTP 作为临时方案
  - 重新生成证书
  - 检查 Nginx 配置

**风险 4：性能不达标**
- **预防措施：**
  - 进行压力测试
  - 优化数据库查询
  - 使用 CDN 加速
- **应对措施：**
  - 增加服务器资源
  - 优化代码和配置
  - 使用负载均衡

**风险 5：安全漏洞**
- **预防措施：**
  - 定期更新依赖包
  - 使用强密码和密钥
  - 配置防火墙规则
- **应对措施：**
  - 及时修复漏洞
  - 监控异常访问
  - 准备应急响应方案

**风险 6：数据丢失**
- **预防措施：**
  - 定期自动备份
  - 使用冗余存储
  - 配置数据复制
- **应对措施：**
  - 从备份恢复数据
  - 使用数据恢复工具
  - 联系专业数据恢复服务

### 10.3 应急预案

**应急预案清单：**
- [ ] 数据备份恢复流程
- [ ] 容器回滚流程
- [ ] 服务降级方案
- [ ] 紧急联系方式
- [ ] 应急响应团队

**应急响应流程：**
```
1. 发现问题 → 2. 评估影响 → 3. 启动应急预案 → 4. 执行恢复 → 5. 验证结果 → 6. 总结改进
```

---

## 附录：完整配置文件

### A.1 `backend/Dockerfile`

```dockerfile
FROM node:20-alpine AS base

FROM base AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM base AS runner
WORKDIR /app
ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 strapi

COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./package.json
COPY --from=builder /app/config ./config
COPY --from=builder /app/public ./public

RUN mkdir -p /app/public/uploads && \
    chown -R strapi:nodejs /app

USER strapi

EXPOSE 1337

CMD ["node", "node_modules/@strapi/strapi/bin/strapi.js", "start"]
```

### A.2 `frontend/Dockerfile`

```dockerfile
FROM node:20-alpine AS base

FROM base AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install --frozen-lockfile

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN pnpm run build

FROM base AS runner
WORKDIR /app
ENV NODE_ENV=production
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

### A.3 `docker/docker-compose.yml`

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: zczk-postgres
    environment:
      POSTGRES_DB: strapi_prod
      POSTGRES_USER: strapi_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - zczk-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U strapi_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
      args:
        DOMAIN: ${DOMAIN}
    container_name: zczk-backend
    env_file:
      - ../backend/.env.production
    environment:
      DATABASE_HOST: postgres
      DATABASE_PASSWORD: ${POSTGRES_PASSWORD}
      APP_KEYS: ${APP_KEYS}
      API_TOKEN_SALT: ${API_TOKEN_SALT}
      ADMIN_JWT_SECRET: ${ADMIN_JWT_SECRET}
      TRANSFER_TOKEN_SALT: ${TRANSFER_TOKEN_SALT}
      JWT_SECRET: ${JWT_SECRET}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      DOMAIN: ${DOMAIN}
    ports:
      - "1337:1337"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - backend_uploads:/app/public/uploads
    restart: unless-stopped
    networks:
      - zczk-network

  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
      args:
        DOMAIN: ${DOMAIN}
    container_name: zczk-frontend
    env_file:
      - ../frontend/.env.production
    environment:
      DOMAIN: ${DOMAIN}
    ports:
      - "3000:3000"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - zczk-network

  nginx:
    image: nginx:alpine
    container_name: zczk-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - frontend
      - backend
    restart: unless-stopped
    networks:
      - zczk-network

volumes:
  postgres_data:
  backend_uploads:

networks:
  zczk-network:
    driver: bridge
```

### A.4 `docker/nginx.conf`

```nginx
events {
    worker_connections 1024;
}

http {
    upstream frontend {
        server frontend:3000;
    }

    upstream backend {
        server backend:1337;
    }

    server {
        listen 80;
        server_name szczk.com www.szzczk.com;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name szczk.com www.szzczk.com;

        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        location / {
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /api {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /uploads {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

### A.5 `scripts/generate-secrets.sh`

```bash
#!/bin/bash

set -e

echo "🔐 生成生产环境环境变量..."

if ! command -v openssl &> /dev/null; then
    echo "❌ 错误: openssl 未安装"
    exit 1
fi

generate_random() {
    openssl rand -hex $1
}

POSTGRES_PASSWORD=$(generate_random 16)
APP_KEYS=$(generate_random 16),$(generate_random 16),$(generate_random 16),$(generate_random 16)
API_TOKEN_SALT=$(generate_random 16)
ADMIN_JWT_SECRET=$(generate_random 16)
TRANSFER_TOKEN_SALT=$(generate_random 16)
JWT_SECRET=$(generate_random 16)
ENCRYPTION_KEY=$(generate_random 16)

if [ -n "$1" ]; then
    DOMAIN="$1"
else
    read -p "请输入你的域名（例如: szczk.com）: " DOMAIN
    if [ -z "$DOMAIN" ]; then
        echo "❌ 错误: 域名不能为空"
        exit 1
    fi
fi

mkdir -p docker

if [ -f docker/.env ]; then
    read -p "⚠️  docker/.env 已存在，是否覆盖？(y/N): " overwrite
    if [ "$overwrite" != "y" ] && [ "$overwrite" != "Y" ]; then
        echo "❌ 操作已取消"
        exit 0
    fi
    cp docker/.env docker/.env.backup.$(date +%Y%m%d_%H%M%S)
    echo "📦 已备份旧文件"
fi

cat > docker/.env << EOF
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
APP_KEYS=$APP_KEYS
API_TOKEN_SALT=$API_TOKEN_SALT
ADMIN_JWT_SECRET=$ADMIN_JWT_SECRET
TRANSFER_TOKEN_SALT=$TRANSFER_TOKEN_SALT
JWT_SECRET=$JWT_SECRET
ENCRYPTION_KEY=$ENCRYPTION_KEY
DOMAIN=$DOMAIN
EOF

echo "✅ 环境变量已生成到 docker/.env"
```

### A.6 `scripts/deploy.sh`

```bash
#!/bin/bash

set -e

echo "🚀 开始部署生产环境..."

cd docker

docker-compose down

docker-compose up -d --build

echo "⏳ 等待 PostgreSQL 启动..."
MAX_RETRIES=30
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if docker-compose ps postgres | grep -q "healthy"; then
        echo "✅ PostgreSQL 已就绪"
        break
    fi
    sleep 2
    RETRY_COUNT=$((RETRY_COUNT + 1))
done

echo "⏳ 等待 Strapi 启动..."
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if docker-compose logs backend 2>/dev/null | grep -q "Server is now ready"; then
        echo "✅ Strapi 已就绪"
        break
    fi
    sleep 2
    RETRY_COUNT=$((RETRY_COUNT + 1))
done

echo "📊 检查数据..."
PRODUCT_COUNT=$(docker-compose exec -T backend npm run strapi list products 2>/dev/null | grep -c "id" || echo "0")

if [ "$PRODUCT_COUNT" -eq "0" ]; then
    echo "📥 数据库为空，开始导入数据..."
    docker-compose exec backend npm run strapi import
    echo "✅ 数据导入完成"
else
    echo "✅ 数据已存在，跳过导入"
fi

echo "✅ 部署完成！"
docker-compose ps
```

---

## 总结

本方案提供了一个完整的开发/生产环境分离解决方案，具有以下特点：

✅ **可操作性**：详细的步骤和脚本，易于执行
✅ **可扩展性**：模块化设计，便于扩展新功能
✅ **安全性**：多层安全措施，保护敏感信息
✅ **自动化**：自动化部署和监控，减少人工操作
✅ **可维护性**：清晰的文档和日志，便于维护

**关键成功因素：**
1. 严格按照步骤执行
2. 充分测试后再部署到生产环境
3. 定期备份和监控
4. 及时处理问题和优化性能

**预期效果：**
- 开发环境快速启动，便于功能迭代
- 生产环境稳定运行，支持高并发
- 数据安全可靠，可快速恢复
- 运维自动化，减少人工干预